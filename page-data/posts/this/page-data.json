{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/this","webpackCompilationHash":"aaf3023d1b1dacafd5c0","result":{"data":{"markdownRemark":{"id":"78fd14e8-8826-5aac-8c31-238a1f295490","html":"<h2 id=\"this란-\"><a href=\"#this%EB%9E%80-\" aria-label=\"this란  permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>this란 ??</h2>\n<p>현재 실행 문맥이다.<br>\n실행 문맥이란 현재 문맥에서 <strong>호출자</strong>가 누구냐? 라는것입니다.</p>\n<p>함수 실행 컨텍스트(실행 가능한 코드 환경)에 this가 존재하고 있고, 이 this는 <strong>함수의 호출 방식</strong>에 의해 값이 <strong>결정</strong>된다.</p>\n<ol>\n<li>일반 함수 호출</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> <span class=\"token function-variable function\">func</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 코드는 window가 출력된다.<br>\n이유는 함수는 기본적으로 전역 함수이고 실행 컨텍스트의 Global Object에 등록되기 때문에 전역 객체인 window가 func 함수를 호출하는 것과 동일한 것이다.<br>\n따라서 window(전역 객체)가 func 함수를 호출한 것이기 때문에 위 코드에서의 this는 window 이다.</p>\n<ol start=\"2\">\n<li>메서드 호출</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">func</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 코드는 obj가 출력된다.<br>\n이유는 함수가 obj 객체의 func 프로퍼티에 값으로 존재하고 있기 때문이다.(이 경우 함수를 메소드라 부른다.)<br>\nfunc 메소드를 호출하기 위해서는 obj에 접근해야 하고 obj.func()로 호출한다.<br>\nobj에 접근해서 obj로 메소드를 호출하기 때문에 this는 obj가 된다.</p>\n<ol start=\"3\">\n<li>생성자 함수 호출</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> newFunc <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 코드는 newFunc가 출력된다.<br>\n이유는 생성자 함수를 호출해서 인스턴스를 생성한 경우 this는 인스턴스를 가리킨다.<br>\n인스턴스라 함은 newFunc를 말한다.<br>\nnew 키워드를 사용해서 생성자 함수를 호출하면 생성자 함수를 온전히 복사해서 인스턴스에 할당한다.<br>\n인스턴스는 new 키워드를 사용해서 호출한 생성자 함수의 복사본으로 인스턴스에서는 생성자 함수가 가지고 있는 모든<br>\n리소스를 사용할 수 있다.<br>\nnewFunc 인스턴스가 가지고 있는 함수에 접근하기 위해서는 newFunc에 접근해야하고 newFunc를 접근해서<br>\n호출해야하므로 this는 newFunc이다.</p>\n<ol start=\"4\">\n<li>call, apply, bind 호출</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">func</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">func</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>second<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">func</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>third<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 코드는 first, second, third가 출력된다.<br>\n이유는 call, apply, bind 메소드는 첫번째 인자로 this에 바인딩 시킬 object를 받는데 call, apply, bind는 Function(함수 최상위 프로토타입)의 메서드로 자바스크립트에서 함수는 call, apply, bind 메서드를 호출할 수 있다.<br>\n따라서 this는 first, second, third가 된다.</p>","fields":{"slug":"/posts/this","tagSlugs":["/tag/javascript/","/tag/this/"]},"frontmatter":{"date":"2019-10-31","description":"this에 대한 글 작성","tags":["javascript","this"],"title":"This"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/this"}}}