{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/promise","webpackCompilationHash":"4a11c98968493b75aff5","result":{"data":{"markdownRemark":{"id":"2caf1d99-1756-5c11-80ca-992babea955d","html":"<h2 id=\"promise프로미스\"><a href=\"#promise%ED%94%84%EB%A1%9C%EB%AF%B8%EC%8A%A4\" aria-label=\"promise프로미스 permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Promise(프로미스)</h2>\n<p>javascript는 비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다.<br>\n하지만 이 전통적인 콜백 패턴은 가동석이 나쁘고 비동기 처리중 발생한 에러의<br>\n예외 처리가 곤란하며 여러 개의 비동기 처리 로직을 한꺼번에 처리하는 것도 한계가<br>\n뚜렷하다.<br>\n비동기 처리를 위해 콜백 패턴을 사용하면 처리 순서를 보장하기 위해<br>\n여러 개의 콜백 함수가 중첩되어 복잡도가 높아지는 콜백 헬이 발생하는<br>\n단점도 있다.</p>\n<p>▼▼콜백 헬이 발생하는 사례▼▼</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">step1(function(value1) {\n  step2(value1, function(value2) {\n    step3(value2, function(value3) {\n      step4(value3, function(value4) {\n        step5(value4, function(value5) {\n            // value5를 사용하는 처리\n        });\n      });\n    });\n  });\n});</code></pre></div>\n<p>콜백 헬이 발생하는 이유는 비동기 처리는 실행 완료를 기다리지 않고<br>\n다음 로직을 실행한다.<br>\n따라서 비동기 함수 내에서 처리 결과를 반환하면 기대한 대로 동작하지 않는다.</p>\n<p>이 문제점을 보완한 Promise가 ES6에서 도입됬다.</p>\n<p>Promise는 Promise 생성자 함수를 통해 인스턴스화한다.<br>\nPromise 생성자 함수는 비동기 작업을 수행 할 콜백 함수를 인자로 전달받는데<br>\n이 콜백 함수는 resolve와 reject 함수를 인자로 전달받는다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Promise 객체의 생성\nconst promise = new Promise((resolve, reject) =&gt; {\n  // 비동기 작업을 수행한다.\n\n  if (/* 비동기 작업 수행 성공 */) {\n    resolve(&#39;result&#39;);\n  }\n  else { /* 비동기 작업 수행 실패 */\n    reject(&#39;failure reason&#39;);\n  }\n});</code></pre></div>\n<p>Promise는 비동기 처리가 성공(fulfilled)했는지 실패(rejected)했는지 등의<br>\n상태 정보를 갖는다.</p>\n<table>\n<thead>\n<tr>\n<th>상태</th>\n<th align=\"center\">의미</th>\n<th align=\"right\">구현</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">pending</code></td>\n<td align=\"center\">비동기 처리가 아직 수행되지<br>않은 상태</td>\n<td align=\"right\">resolve 또는 reject 함수가 아직 <br>호출되지 않은 상태</td>\n</tr>\n<tr>\n<td></td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n<tr>\n<td></td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">fulfilled</code></td>\n<td align=\"center\">비동기 처리가 수행된 상태(성공)</td>\n<td align=\"right\">resolve 함수가 호출된 상태</td>\n</tr>\n<tr>\n<td></td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n<tr>\n<td></td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">rejected</code></td>\n<td align=\"center\">비동기 처리가 수행된 상태(실패)</td>\n<td align=\"right\">reject 함수가 호출된 상태</td>\n</tr>\n<tr>\n<td></td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n<tr>\n<td></td>\n<td align=\"center\"></td>\n<td align=\"right\"></td>\n</tr>\n<tr>\n<td><code class=\"language-text\">settled</code></td>\n<td align=\"center\">비동기 처리가 수행된 상태<br>(성공 또는 실패)</td>\n<td align=\"right\">resolve 또는 reject 함수가 호출된 상태</td>\n</tr>\n</tbody>\n</table>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const promiseAjax = (method, url, payload) =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    const xhr = new XMLHttpRequest();\n    xhr.open(method, url);\n    xhr.setRequestHeader(&#39;Content-type&#39;, &#39;application/json&#39;);\n    xhr.send(JSON.stringify(payload));\n\n    xhr.onreadystatechange = function () {\n      // 서버 응답 완료가 아니면 무시\n      if (xhr.readyState !== XMLHttpRequest.DONE) return;\n\n      if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 400) {\n        // resolve 메소드를 호출하면서 처리 결과를 전달\n        resolve(xhr.response); // Success!\n      } else {\n        // reject 메소드를 호출하면서 에러 메시지를 전달\n        reject(new Error(xhr.status)); // Failed...\n      }\n    };\n  });\n};</code></pre></div>\n<p>Promise 후속 처리 메서드<br>\nPromise로 구현된 비동기 함수는 Promise 객체를 반환해야한다.<br>\nPromise로 구현된 비동기 함수를 호출하는 caller는 Promise 객체의 후속 처리<br>\n메서드를 통해 비동기 처리 결과 또는<br>\n에러 메시지를 전달받아 처리한다.<br>\nPromise 객체는 상태를 갖고있다고 했는데 이 상태에 따라 후속 처리 메서드를 체이닝 방식으로 호출한다.</p>\n<p>then<br>\nthen 메서드는 두 개의 콜백 함수를 인자로 전달 받는다.<br>\n첫번째 콜백 함수는 성공(resolve 함수가 호출된 상태)시 호출되고<br>\n두번째 함수는 실패(reject 함수가 호출된 상태)시 호출된다.<br>\n이 then 메서드는 Promise를 반환한다.</p>\n<p>catch<br>\n예외(비동기 처리에서 발생한 에러와 then 메서드에서 발생한 에러)가 발생하면 호출된다.<br>\n이 catch 메서드는 Promise를 반환한다.</p>\n<p>비동기 함수의 처리 결과를 가지고 다른 비동기 함수를 호출해야 하는 경우 함수의<br>\n호출이 중첩되어 복잡도가 높아지는 콜백 헬이 발생한다.<br>\nPromise는 후속 처리 메서드를 체이닝하여 여러 개의 Promise를 연결하여 사용할 수 있는데 이것으로 콜백 헬을 해결한다.</p>","fields":{"slug":"/posts/promise","tagSlugs":["/tag/javascript/","/tag/비동기/","/tag/asynchronous/"]},"frontmatter":{"date":"2019-09-05","description":"promise에 대한 글","tags":["javascript","비동기","asynchronous"],"title":"Promise"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/posts/promise"}}}