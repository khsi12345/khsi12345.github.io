<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[세상 가장 작은 사람의 개발 이야기]]></title><description><![CDATA[세상 가장 작은 사람의 개발 이야기]]></description><link>https://khsi12345.github.io/</link><generator>RSS for Node</generator><lastBuildDate>Sat, 24 Aug 2019 08:23:19 GMT</lastBuildDate><item><title><![CDATA[Sementic HTML(의미론적 HTML)]]></title><description><![CDATA[Sementix HTML 요소들에 대한 내용]]></description><link>https://khsi12345.github.io//posts/HTML/</link><guid isPermaLink="false">https://khsi12345.github.io//posts/HTML/</guid><pubDate>Thu, 22 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;html&quot;&gt;&lt;a href=&quot;#html&quot; aria-label=&quot;html permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;HTML&lt;/h1&gt;
&lt;p&gt;HyperText Markup Language.&lt;br&gt;
Text를 Markup 하는 언어.&lt;br&gt;
HTML === 웹 브라우저가 유일하게 읽을 수 있는 문서.&lt;br&gt;
웹 브라우저가 화면에 뷰를 렌더할때 HTML을 쭉~ 훑는다.&lt;br&gt;
훑은 순서대로 화면에 렌더하기 때문에 HTML의 구조, 컨텐츠를 의미있게 작성해야만 한다.&lt;br&gt;
브라우저가 HTML을 읽고 화면에 렌더할 컨텐츠를 감싸는 태그들이 있다.&lt;br&gt;
태그들은 종속관계(중첩)를 가진다.&lt;br&gt;
이 태그들은 의미가 있는 태그들이 있고, 의미가 없는 태그들이 있다.&lt;br&gt;
그런데 이 의미가 있는 태그들은 HTML5가 나오면서 생겼고, HTML5가 나오기 전에는 의미가 있는 태그들이 없어서 그저 컨텐츠를 감싸고 구조를 만들었다.&lt;br&gt;
의미란 것이 브라우저가 HTML을 읽으면서 태그를 읽었을때 이 태그의 컨텐츠가 이런 의미를 가지고 있단걸 알게됩니다.&lt;/p&gt;
&lt;p&gt;의미를 가지고 있는 여러가지 태그들 중에는&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;headers&amp;gt; &amp;lt;nav&amp;gt; &amp;lt;article&amp;gt; &amp;lt;section&amp;gt; &amp;lt;aside&amp;gt; &amp;lt;footer&amp;gt; &amp;lt;main&amp;gt;
&amp;lt;figure&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;기존 태그들 중에는&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;div&amp;gt; &amp;lt;p&amp;gt; &amp;lt;span&amp;gt; &amp;lt;a&amp;gt; &amp;lt;h1,2,3,4,5&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 있다.(이 외에도 더 있어요~ )&lt;/p&gt;
&lt;p&gt;의미가 있는 태그들을 사용하는 궁극적인 목표는
브라우저가 컨텐츠의 성격, 의미를 알게하는 것도 있지만, SEO(검색최적화)의 효율 높이기 위한것도 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[SEO(검색최적화)]]></title><description><![CDATA[SEO(검색 최적화)에 대한 내용]]></description><link>https://khsi12345.github.io//posts/SEO/</link><guid isPermaLink="false">https://khsi12345.github.io//posts/SEO/</guid><pubDate>Thu, 22 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;세계의 누군가가 어떤 키워드로 검색했을때 1페이지에 잘 뜨게 하려면&lt;/p&gt;
&lt;p&gt;HTML을 컴퓨터가 이해할 수 있도록 만든다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&lt;/code&gt;에 페이지 정보를 최대한 자세하게 작성한다.&lt;/li&gt;
&lt;li&gt;react에서는 helmet이라는 것을 이용해서 잘 노출될 수 있게 할 수 있다.&lt;/li&gt;
&lt;li&gt;구글 검색 엔진이 크롤링을 하는데 내가 만든 사이트를 크롤링 할 수 있게 robots.txt를 만들고&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;user-agent:*&quot;&gt;&lt;pre class=&quot;language-user-agent:*&quot;&gt;&lt;code class=&quot;language-user-agent:*&quot;&gt;   Allow: /
   Sitemap: url&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그리고 이전 블로그에서 작성했던 HTML의 의미있는 태그들을 꼭 사용한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[HTTP]]></title><description><![CDATA[HTTP, HTTP 메서드, HTTP STATUS에 대한 내용]]></description><link>https://khsi12345.github.io//posts/HTTP/</link><guid isPermaLink="false">https://khsi12345.github.io//posts/HTTP/</guid><pubDate>Wed, 21 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2 id=&quot;http&quot;&gt;&lt;a href=&quot;#http&quot; aria-label=&quot;http permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;HTTP&lt;/h2&gt;
&lt;p&gt;HyperText Transfer Protocol&lt;br&gt;
HTML 문서를 교환하기 위해 만들어진 protocol(규약, 통신)&lt;br&gt;
즉, 웹에서 네트워크로 서버끼리 통신을 할때 어떠한 규칙(형식)으로 서로 통신을 할건지 규정해놓은 것&lt;br&gt;
프론트엔드 서버와 클라이언트 간의 통신에 사용된다.&lt;br&gt;
TCP/IP 기반으로 되어있다.&lt;/p&gt;
&lt;h3 id=&quot;통신-방식&quot;&gt;&lt;a href=&quot;#%ED%86%B5%EC%8B%A0-%EB%B0%A9%EC%8B%9D&quot; aria-label=&quot;통신 방식 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;통신 방식&lt;/h3&gt;
&lt;p&gt;기본적으로 요청(request)과 응답(response) 구조로 되어있다.&lt;br&gt;
클라이언트가 HTTP request를 서버에 전송하면 서버는 HTTP response를 보내주는 구조.&lt;br&gt;
클라이언트와 서버 간 모든 통신은 request와 response로 이뤄져 있다.&lt;/p&gt;
&lt;h3 id=&quot;http-상태&quot;&gt;&lt;a href=&quot;#http-%EC%83%81%ED%83%9C&quot; aria-label=&quot;http 상태 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;HTTP 상태&lt;/h3&gt;
&lt;p&gt;request를 전송하면 응답만한다.&lt;br&gt;
여러 request, response가 연결되어 있지 않고 각각 독립적이다.&lt;br&gt;
전에 보낸 request, response를 알지 못하기 때문에 여러 request, response의 진행이나 데이터가 필요할 때는 쿠키나 세션을 사용하게 된다.&lt;/p&gt;
&lt;h3 id=&quot;http-request-구조&quot;&gt;&lt;a href=&quot;#http-request-%EA%B5%AC%EC%A1%B0&quot; aria-label=&quot;http request 구조 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;HTTP request 구조&lt;/h3&gt;
&lt;p&gt;HTTP request 구조는 크게 3부분으로 구성된다.&lt;/p&gt;
&lt;h4 id=&quot;status-line&quot;&gt;&lt;a href=&quot;#status-line&quot; aria-label=&quot;status line permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;status line&lt;/h4&gt;
&lt;p&gt;status line 구조는 3부분으로 구성된다.&lt;/p&gt;
&lt;p&gt;HTTP Method&lt;br&gt;
해당 request가 의도한 action을 정의하는 부분.&lt;br&gt;
HTTP Method는 GET, POST, PUT, DELETE, OPTIONS 등이 있다.&lt;/p&gt;
&lt;p&gt;request target&lt;br&gt;
해당 request가 전송될 목표 uri(목적지).&lt;/p&gt;
&lt;p&gt;HTTP Version&lt;br&gt;
HTTP Version을 나타낸다.&lt;/p&gt;
&lt;h4 id=&quot;headers&quot;&gt;&lt;a href=&quot;#headers&quot; aria-label=&quot;headers permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Headers&lt;/h4&gt;
&lt;p&gt;해당 request에 대한 추가 정보를 담고 있는 부분.&lt;/p&gt;
&lt;p&gt;정보&lt;br&gt;
Host: request가 전송되는 tartget의 host url.&lt;br&gt;
User-Agent: request를 보내는 클라이언트의 대한 정보.(웹 브라우저에 대한 정보)&lt;br&gt;
Accept: 해당 request가 받을 수 있는 response 타입.&lt;br&gt;
Connection: 해당 request가 끝난 후에 클라이언트와 서버가 계속해서 네트워크 통신을 유지 할것인지 끊을것인지에 대한 부분.&lt;br&gt;
Content-Type: 해당 request가 보내는 메세지 body의 타입.(application/json)&lt;/p&gt;
&lt;h4 id=&quot;body&quot;&gt;&lt;a href=&quot;#body&quot; aria-label=&quot;body permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Body&lt;/h4&gt;
&lt;p&gt;해당 request의 실제 메세지 내용.&lt;br&gt;
Body가 없는 request도 있는데 GET request들이 대부분 body가 없는 경우가 많다.&lt;/p&gt;
&lt;h3 id=&quot;http-response-구조&quot;&gt;&lt;a href=&quot;#http-response-%EA%B5%AC%EC%A1%B0&quot; aria-label=&quot;http response 구조 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;HTTP response 구조&lt;/h3&gt;
&lt;p&gt;HTTP response 구조는 크게 3부분으로 구성된다.&lt;/p&gt;
&lt;h4 id=&quot;status-line-1&quot;&gt;&lt;a href=&quot;#status-line-1&quot; aria-label=&quot;status line 1 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Status line&lt;/h4&gt;
&lt;p&gt;response의 상태를 나타내는 부분.&lt;br&gt;
3부분으로 구성되어 있다.&lt;/p&gt;
&lt;p&gt;HTTP Version&lt;/p&gt;
&lt;p&gt;status code&lt;br&gt;
response 상태를 나타내는 숫자로 되어 있는 코드.&lt;/p&gt;
&lt;h4 id=&quot;headers-1&quot;&gt;&lt;a href=&quot;#headers-1&quot; aria-label=&quot;headers 1 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Headers&lt;/h4&gt;
&lt;p&gt;request headers와 거의 동일한데 response에서만 사용되는 값들을 가지고 있다.&lt;/p&gt;
&lt;h4 id=&quot;body-1&quot;&gt;&lt;a href=&quot;#body-1&quot; aria-label=&quot;body 1 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Body&lt;/h4&gt;
&lt;p&gt;request Body와 일반적으로 동일하다.&lt;br&gt;
모든 response가 Body가 있는건 아니다.&lt;br&gt;
데이터를 response 할 필요가 없을 경우 비어있게 된다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[SASS SCSS 삽질]]></title><description><![CDATA[sass / scss 공부 및 적용]]></description><link>https://khsi12345.github.io//posts/react/component-styling-sass-scss/error-fixed/</link><guid isPermaLink="false">https://khsi12345.github.io//posts/react/component-styling-sass-scss/error-fixed/</guid><pubDate>Tue, 20 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;react-miniter에 sass / scss 적용하려고 node-sass를 설치했다.&lt;br&gt;
그리곤 VScode에서 @mixin @includes 문법을 사용하고는 로컬 라이브 서버로&lt;br&gt;
제대로 적용이 되었는지 확인했다.&lt;br&gt;
내 기대와는 다르게 에러가 발생했고 개발자 도구 콘솔에서 확인해보니&lt;br&gt;
No mixin named (mixin이름) 이라고 뜸과 동시에&lt;br&gt;
윗쪽에는 Uncaught Error:&lt;del&gt;&lt;/del&gt; 로 에러 발생을 알려주고 있었다.&lt;/p&gt;
&lt;p&gt;여기서가 삽질의 시작이었다..&lt;br&gt;
해결하고 나서 보니 에러는 mixin의 이름을 찾을 수 없다 였는데…&lt;br&gt;
윗쪽의 Uncaugth Error로 구글링해서 해결하고 있었다.&lt;/p&gt;
&lt;p&gt;구글링하면 나오는 것들은 webpack, babel, sass-loader, css-loader 등등…
그리하여 이것들을 참고하면 해결이 되겠다는 생각을 가지고 package.json에서 수정해보기도&lt;br&gt;
하고 터미널에서 install도 해보고 node, node_modules도 지워보고 다시 설치해보고 반복했다.&lt;/p&gt;
&lt;p&gt;적용해보고 안되면 또 다르게 검색해서 또 적용해보고 또 안되면 적용 안해본것들을 적용해보고의 무한 반복이었다.&lt;br&gt;
이렇게 24시간 이상이라는 시간을 쓰고… 예리님께 질문을 했는데&lt;br&gt;
No mixin named (mixin이름) 에러를 보시고는 scss 문법을 잘못 쓴거 같다라고&lt;br&gt;
말해주셔서 바로 해당 scss파일을 확인했다.&lt;br&gt;
A라는 scss 파일에서 @mixin을 정의했고, B라는 scss 파일에서 @includes로 mixin을 사용하는 것인데
B라는 scss 파일에서 A라는 scss 파일에 존재하고 있는 mixin을&lt;br&gt;
못찾는거 같아 B라는 scss 파일에 존재하고있는 includes를 A라는 scss 파일에 적용해봤다.&lt;br&gt;
그러고 로컬 라이브 서버로 확인을 해봤는데 에러가 발생하지 않는다!!!!!!!!!!!!!(후…)&lt;br&gt;
그리고 다시 원상복구 그리고 확인 … 에러 발생!!!!&lt;br&gt;
이제 정확한 원인을 찾았다.&lt;/p&gt;
&lt;p&gt;바로 B라는 scss 파일에서 A라는 scss 파일을 참조? 접근? 할 수 있게&lt;br&gt;
@import시켜주었다.&lt;br&gt;
그리고 @import 하기 전에 에러나던 상황에서의 코드 그대로를 가지고 로컬 라이브&lt;br&gt;
서버로 확인을 해보니 드디어 에러가 발생하지 않았다.(ㅠ-ㅠ)&lt;/p&gt;
&lt;p&gt;이 삽질을 통해 얻은 것은&lt;br&gt;
에러부터 잘 파악하자!! 이다.&lt;br&gt;
이후 해결과정에서도 해결이 안되면 새로운 환경을 만들어서 적용해보자!! 이다.&lt;br&gt;
그리고 에러 내용이 무엇을 찾을 수 없다던가, 접근을 할 수 없다던가, 이런 종류라면&lt;br&gt;
경로, import시켜주는거 또는 디렉토리 구조, 디렉토리, 파일 존재 여부 를 확인해보자!!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[새로운 프로젝트 시작 순서]]></title><description><![CDATA[새로운 프로젝트 시작할때 환경 구성 순서]]></description><link>https://khsi12345.github.io//posts/new-project-create/</link><guid isPermaLink="false">https://khsi12345.github.io//posts/new-project-create/</guid><pubDate>Tue, 20 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h3 id=&quot;새로운-프로젝트-생성-순서&quot;&gt;&lt;a href=&quot;#%EC%83%88%EB%A1%9C%EC%9A%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%83%9D%EC%84%B1-%EC%88%9C%EC%84%9C&quot; aria-label=&quot;새로운 프로젝트 생성 순서 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;새로운 프로젝트 생성 순서&lt;/h3&gt;
&lt;p&gt;1.github에서 새로운 레포지토리 생성&lt;br&gt;
(내 프로젝트 디렉토리와 연결될 repo 생성)&lt;br&gt;
2.npx create-react-app 디렉토리명&lt;br&gt;
(react 환경 구성, npx는 npm5.2+버전의 패키지 실행 도구이며, 딱 로컬(디렉토리)에서만 react 환경 구성해줌.)&lt;br&gt;
3.git init&lt;br&gt;
(해당 디렉토리가 git과 연결할 수 있게 초기화)&lt;br&gt;
4.git remote add origin 레포주소&lt;br&gt;
(git과 해당 디렉토리는 연결&lt;code class=&quot;language-text&quot;&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;)&lt;br&gt;
5.npm init&lt;br&gt;
(해당 디렉토리 npm 초기화, package.json 파일 생성)&lt;br&gt;
6.리액트 라우터 설치 &gt; yarn add react-router-dom / npm install react-router-dom —save&lt;br&gt;
7.리액트에 eslint와 prettier 적용하기 &lt;a href=&quot;https://velog.io/@velopert/eslint-and-prettier-in-react&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://velog.io/@velopert/eslint-and-prettier-in-react&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React component styling(SASS / SCSS)]]></title><description><![CDATA[sass / scss 공부 및 적용]]></description><link>https://khsi12345.github.io//posts/react/component-styling-sass-scss/</link><guid isPermaLink="false">https://khsi12345.github.io//posts/react/component-styling-sass-scss/</guid><pubDate>Sun, 18 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2 id=&quot;react-component-styling-중-sassscss&quot;&gt;&lt;a href=&quot;#react-component-styling-%EC%A4%91-sassscss&quot; aria-label=&quot;react component styling 중 sassscss permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;React Component Styling 중 Sass(Scss)&lt;/h2&gt;
&lt;p&gt;sass(scss)는 Syntactically Awesome Style Sheets의 약자로 문법적으로 어~섬한 스타일 시트다.&lt;br&gt;
sass(scss)는 복잡한 작업을 쉽게 해주고 코드의 재활용성과 가독성을 up시켜주며 유지보수를 쉽게 해준다.&lt;br&gt;
CSS pre-processor로 CSS 전처리기이다.&lt;br&gt;
확장자는 .sass / .scss 이고 개발자가 개발할때는 .sass / .scss 확장자 파일로 코드를 작성하고&lt;br&gt;
컴파일러를 통해 브라우저가 읽을 수 있는 css로 변환된다.(브라우저는 .sass / .scss 읽지 못함)&lt;/p&gt;
&lt;p&gt;.sass는 문법이 간결한 편이다.&lt;br&gt;
.scss와의 차이점은 {}와;를 쓰지않고 들여쓰기로 선택자의 유효범위를 구분한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;.list
  width: 100px
  float: left
  li
    color: red
    background: url(&amp;quot;./image.jpg&amp;quot;)
    &amp;amp;:last-child
      margin-right: -10px&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;=border-radius($radius)
  -webkit-border-radius: $radius
  -moz-border-radius:    $radius
  -ms-border-radius:     $radius
  border-radius:         $radius

.box
  +border-radius(10px)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;.scss는 css와 완전한 호환을 이룬다.&lt;br&gt;
css처럼 {}로 선택자의 유효범위를 구분하며 ;도 사용한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;.list {
  width: 100px;
  float: left;
  li {
    color: red;
    background: url(&amp;quot;./image.jpg&amp;quot;);
    &amp;amp;:last-child {
      margin-right: -10px
    }
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;@mixin border-radius($radius) {
  -webkit-border-radius: $radius;
     -moz-border-radius: $radius;
      -ms-border-radius: $radius;
          border-radius: $radius;
}

.box { @include border-radius(10px); }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;중첩&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;.section {
  width: 100%;
  .list {
    padding: 20px;
    li {
      float: left;
    }
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;#x26; 키워드를 사용해서 상위 선택자를 참조하여 치환할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;.btn {
  position: absolute;
  &amp;amp;.active {
    color: red;
  }
}

.list {
  li {
    &amp;amp;:last-child {
      margin-right: 0;
    }
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;중첩된 속성&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;.box {
  font-weight: bold;
  font-size: 10px;
  font-family: sans-serif;
  margin-top: 10px;
  margin-left: 20px;
  padding-bottom: 40px;
  padding-right: 30px;
}
================================
.box {
  font: {
    weight: bold;
    size: 10px;
    family: sans-serif;
  };
  margin: {
    top: 10px;
    left: 20px;
  };
  padding: {
    bottom: 40px;
    right: 30px;
  };
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;변수&lt;br&gt;
사용하고자 하는 변수명 앞에 $ 키워드 사용&lt;/p&gt;
&lt;p&gt;내용 추가 및 보완 예정&lt;/p&gt;</content:encoded></item><item><title><![CDATA[REACT ing2]]></title><description><![CDATA[REACT를 배움, 공부.]]></description><link>https://khsi12345.github.io//posts/react3/</link><guid isPermaLink="false">https://khsi12345.github.io//posts/react3/</guid><pubDate>Sun, 18 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h2 id=&quot;react에서-event-data를-사용해보며&quot;&gt;&lt;a href=&quot;#react%EC%97%90%EC%84%9C-event-data%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EB%A9%B0&quot; aria-label=&quot;react에서 event data를 사용해보며 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;react에서 event, data를 사용해보며&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;handleInputEmail = (e) =&amp;gt; {
    this.setState({
      email: e.target.value,
    });
  };

  handleInputPw = (e) =&amp;gt; {
    this.setState({
      pw: e.target.value,
    });
  };

&amp;lt;input
    type=&amp;quot;text&amp;quot;
    placeholder=&amp;quot;Phone, email, or username&amp;quot;
    className=&amp;quot;inputEmail&amp;quot;
    onChange={this.handleInputEmail}
    /&amp;gt;
&amp;lt;input
    type=&amp;quot;text&amp;quot;
    placeholder=&amp;quot;Password&amp;quot;
    className=&amp;quot;inputPw&amp;quot;
    onChange={this.handleInputPw}
    /&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 이벤트 핸들러가 같은 동작을 할 경우 처음엔 각각의 input 요소&lt;br&gt;
그리고 state인 email과 pw로 인해 1개의 이벤트 핸들러에서는 email state를,&lt;br&gt;
다른 1개의 이벤트 핸들러에서는 pw state를 다뤘다.&lt;br&gt;
하지만 갱신해줘야하는 데이터(입력요소의 값)를 받을 대상이 다를 뿐이지 결국에는&lt;br&gt;
데이터를 가지고 갱신하는 일은 같은 것이다.&lt;/p&gt;
&lt;p&gt;위 코드를 이렇게 수정할 수 있겠다.&lt;br&gt;
2개의 이벤트 핸들러를 1개로 줄이고 각각의 input 요소에서 사용할 수 있게한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;handleInput = (e) =&amp;gt; {
    this.setState({
      [e.target.name]: e.target.value,
    });
  };

&amp;lt;input
    type=&amp;quot;text&amp;quot;
    name=&amp;quot;email&amp;quot;
    placeholder=&amp;quot;Phone, email, or username&amp;quot;
    className=&amp;quot;inputEmail&amp;quot;
    onChange={this.handleInput}
    /&amp;gt;
&amp;lt;input
    type=&amp;quot;text&amp;quot;
    name=&amp;quot;pw
    placeholder=&amp;quot;Password&amp;quot;
    className=&amp;quot;inputPw&amp;quot;
    onChange={this.handleInput}
    /&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;어떻게 이런게 가능한 것일까??&lt;br&gt;
이벤트 핸들러는 이벤트 객체를 받을 수 있는데 그 이벤트 객체는 이벤트를 일으킨&lt;br&gt;
요소다.&lt;br&gt;
즉 해당 요소에서 이벤트가 발생하면 &lt;code class=&quot;language-text&quot;&gt;[e.target.name]&lt;/code&gt;은 name을 email 또는&lt;br&gt;
pw 구분한다.&lt;br&gt;
name이 email인 요소면 &lt;code class=&quot;language-text&quot;&gt;email: e.target.value&lt;/code&gt;가 되는것이고&lt;br&gt;
name이 pw인 요소면 &lt;code class=&quot;language-text&quot;&gt;pw:e.gartget.value&lt;/code&gt;가 되는것이다.&lt;/p&gt;
&lt;p&gt;중복을 줄일 수 있는 정말 좋은 방법이다!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[REACT ing]]></title><description><![CDATA[REACT를 배움, 공부.]]></description><link>https://khsi12345.github.io//posts/react2/</link><guid isPermaLink="false">https://khsi12345.github.io//posts/react2/</guid><pubDate>Sat, 17 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;miniter에 react를 적용하게 됐다.&lt;/p&gt;
&lt;h3 id=&quot;cracrate-react-app으로-react-환경을-구성했다&quot;&gt;&lt;a href=&quot;#cracrate-react-app%EC%9C%BC%EB%A1%9C-react-%ED%99%98%EA%B2%BD%EC%9D%84-%EA%B5%AC%EC%84%B1%ED%96%88%EB%8B%A4&quot; aria-label=&quot;cracrate react app으로 react 환경을 구성했다 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;CRA(crate-react-app)으로 react 환경을 구성했다.&lt;/h3&gt;
&lt;h3 id=&quot;앞으로-혼자-개발-할-것이-아니기-때문에-eslint와-prettier로-코딩-환경을-구성했다&quot;&gt;&lt;a href=&quot;#%EC%95%9E%EC%9C%BC%EB%A1%9C-%ED%98%BC%EC%9E%90-%EA%B0%9C%EB%B0%9C-%ED%95%A0-%EA%B2%83%EC%9D%B4-%EC%95%84%EB%8B%88%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-eslint%EC%99%80-prettier%EB%A1%9C-%EC%BD%94%EB%94%A9-%ED%99%98%EA%B2%BD%EC%9D%84-%EA%B5%AC%EC%84%B1%ED%96%88%EB%8B%A4&quot; aria-label=&quot;앞으로 혼자 개발 할 것이 아니기 때문에 eslint와 prettier로 코딩 환경을 구성했다 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;앞으로 혼자 개발 할 것이 아니기 때문에 eslint와 prettier로 코딩 환경을 구성했다.&lt;/h3&gt;
&lt;h4 id=&quot;eslint란&quot;&gt;&lt;a href=&quot;#eslint%EB%9E%80&quot; aria-label=&quot;eslint란 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;eslint란??&lt;/h4&gt;
&lt;p&gt;Javascript linting 유틸리티다.&lt;br&gt;
코드 linting은 특정 스타일 가이드 라인을 준수하니 않는 문제가 있는 패턴이나 코드를 찾는 데 사용되는 정적 분석 유형이다.&lt;br&gt;
eslint가 만들어진 주 이유는 개발자가 자신의 규칙을 만들 수 있도록 하기위한 것이다.&lt;br&gt;
왜? Javascript에서 eslint를 사용할까?&lt;br&gt;
일단 Javascript는 타 언어와 다르게 동적이도 느슨한 언어이다.&lt;br&gt;
그로 인해 오류가 발생하기 쉬운 문제점을 가지고 있다.&lt;br&gt;
이 문제를 쉽게 발견(Javascript코드를 실행하지 않고도)하고 수정 및
오류 방지를 위해 사용한다.&lt;br&gt;
Javascript에 이런 문제를 보완해주는 TypeScript도 있다.  &lt;/p&gt;
&lt;h5 id=&quot;prettier란&quot;&gt;&lt;a href=&quot;#prettier%EB%9E%80&quot; aria-label=&quot;prettier란 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;prettier란??&lt;/h5&gt;
&lt;p&gt;prettier는 코드 포맷터로 코드 스타일을 일관성 있게 만들어 준다.
react는 컴포넌트 단위의 라이브러리이기 때문에 기존에 만들었던 miniter를 쪼개어 나눴다.&lt;/p&gt;
&lt;h3 id=&quot;쪼개진-컴포넌트를js파일-단위-조립해서-하나의-작품으로-만들었다&quot;&gt;&lt;a href=&quot;#%EC%AA%BC%EA%B0%9C%EC%A7%84-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BCjs%ED%8C%8C%EC%9D%BC-%EB%8B%A8%EC%9C%84-%EC%A1%B0%EB%A6%BD%ED%95%B4%EC%84%9C-%ED%95%98%EB%82%98%EC%9D%98-%EC%9E%91%ED%92%88%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%97%88%EB%8B%A4&quot; aria-label=&quot;쪼개진 컴포넌트를js파일 단위 조립해서 하나의 작품으로 만들었다 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;쪼개진 컴포넌트를(js파일 단위) 조립해서 하나의 작품으로 만들었다.&lt;/h3&gt;
&lt;h3 id=&quot;하나의-작품으로-만드는-과정&quot;&gt;&lt;a href=&quot;#%ED%95%98%EB%82%98%EC%9D%98-%EC%9E%91%ED%92%88%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%9C%EB%8A%94-%EA%B3%BC%EC%A0%95&quot; aria-label=&quot;하나의 작품으로 만드는 과정 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;하나의 작품으로 만드는 과정&lt;/h3&gt;
&lt;h4 id=&quot;루트-컴포넌트에-각-컴포넌트를-맞춰준다&quot;&gt;&lt;a href=&quot;#%EB%A3%A8%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90-%EA%B0%81-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%A5%BC-%EB%A7%9E%EC%B6%B0%EC%A4%80%EB%8B%A4&quot; aria-label=&quot;루트 컴포넌트에 각 컴포넌트를 맞춰준다 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;루트 컴포넌트에 각 컴포넌트를 맞춰준다.&lt;/h4&gt;
&lt;p&gt;컴포넌트들(각 파일들)이 분리 되어있기 때문에 독립적인 스코프를 가진다.&lt;br&gt;
A라는 컴포넌트를 B라는 컴포넌트에서 사용하기 위해서는 A라는 컴포넌트에서 &lt;code class=&quot;language-text&quot;&gt;export default 클래스 이름&lt;/code&gt;을 꼭 해줘야하고&lt;br&gt;
B라는 컴포넌트에서는 &lt;code class=&quot;language-text&quot;&gt;import 클래스 이름 from &amp;#39;컴포넌트 경로&amp;#39;&lt;/code&gt;를 꼭 해줘야한다.&lt;br&gt;
export는 다른 컴포넌트에서 사용할 수 있게 내보내는 역할.&lt;br&gt;
import는 다른 컴포넌트를 해당 컴포넌트에서 사용할 수 있게 만드는 역할.&lt;/p&gt;
&lt;h4 id=&quot;컴포넌트-안에서-사용될-데이터state-props를-컨트롤-한다&quot;&gt;&lt;a href=&quot;#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%95%88%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%EB%90%A0-%EB%8D%B0%EC%9D%B4%ED%84%B0state-props%EB%A5%BC-%EC%BB%A8%ED%8A%B8%EB%A1%A4-%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;컴포넌트 안에서 사용될 데이터state props를 컨트롤 한다 permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;컴포넌트 안에서 사용될 데이터(state, props)를 컨트롤 한다.&lt;/h4&gt;
&lt;p&gt;해당 컴포넌트에서 변경 및 유지해야 할 데이터가 있다면 state(상태 데이터)를 정의하고 사용한다.&lt;br&gt;
해당 컴포넌트에서 유지해야 할 데이터가 아니라면 props(부모로 부터 받는 데이터)를 받아 사용한다.&lt;br&gt;
react에서는 DOM에 직접적으로 접근하지 않는다.&lt;br&gt;
ex)document.getSelector() / DOM.addEventlistener() / DOM의 프로퍼티 접근 등등&lt;br&gt;
react에서는 style을 인라인 방식으로 주지 않고 항상 별도의 style 파일에서 정의하고 selector을 이용해서 style을 적용한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[webGame 진행하면서]]></title><description><![CDATA[웹 게임을 진행하면서 쓰는 글.]]></description><link>https://khsi12345.github.io//posts/webGame/</link><guid isPermaLink="false">https://khsi12345.github.io//posts/webGame/</guid><pubDate>Tue, 13 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;class Enemy {
    constructor(eP) {
        console.log(eP)
        this.enemyPosition = eP;
        this.enemycreate;
    }

    enemyCreate()  {

    }
    }
    enemyUnderMove() {

    }

let enemys = new Enemy(enemyPositionY);

window.addEventListener(&amp;#39;load&amp;#39;, e =&amp;gt; {
     enemys.enemyCreate()
     enemys.enemyUnderMove()
     ***setInterval(enemys.enemyCreate.bind(enemys),1000)***
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;문제의 코드!!&lt;br&gt;
이벤트 안에서 setInterval 함수를 사용했다.&lt;br&gt;
그리고 Enemy 클래스의 인스턴스를 만들고 인스턴스로 클래스의 메서드를 호출했다.&lt;br&gt;
정상적으로 작동하는지 확인하기 위해 console.log()로 의심이 되는 데이터들을 찍어보았다.&lt;br&gt;
그 결과는 NaN이 출력이 된다.&lt;/p&gt;
&lt;p&gt;무슨 문제가 발생한것인지 해결하기 위해 내 코드를 계속 보고 수정도 해보고 했지만 해결하지 못하고 있던 와중..&lt;br&gt;
돌리고 있는 로직은 계산 부분이고 계산은 enemyCreate 함수 안에 작성되어있다.&lt;br&gt;
근데 이 돌리고 있는 부분이 문제가 발생한거로 인지를 하고 enemyCreate 함수가 호출되는 지점을 확인했다.&lt;/p&gt;
&lt;p&gt;setInterval 함수 안에서 호출되었고, Enemy 클래스 생성자를 호출해 새로운 인스턴스를 생성한 enemys로 enemyCreate 함수를 호출했다.&lt;/p&gt;
&lt;p&gt;왠지 이 부분이 문제인듯 하다.&lt;br&gt;
구글에서 setInterval을 MDN에서 보니 this의 문제점이 보였다.&lt;br&gt;
setInterval은 setInterval에 전달되는 함수는 호출된 함수에 대한 this 키워드가 전역(window)으로 자동 설정된다고 한다.&lt;br&gt;
즉, 내 코드에서는 this가 enemys(Enemy 클래스의 인스턴스, 즉 Enemy 클래스에서의 this는 enemys를 가리킨다.)다 라고 한것이지만,&lt;br&gt;
무시되고 this가 전역(window)으로 강제 된것이다.&lt;br&gt;
이 문제의 해결방법은 함수를 ES6의 Errow Function으로 하거나, enemys.enemyCreate.bind(enemys)처럼 this를 바인딩 시켜주는 방법이 있다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[REACT]]></title><description><![CDATA[REACT를 배움, 공부.]]></description><link>https://khsi12345.github.io//posts/react/</link><guid isPermaLink="false">https://khsi12345.github.io//posts/react/</guid><pubDate>Tue, 13 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;h1 id=&quot;react&quot;&gt;&lt;a href=&quot;#react&quot; aria-label=&quot;react permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;REACT&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/media/lifecycle.jpeg&quot;&gt;&lt;/p&gt;
&lt;p&gt;라이프 사이클 순서&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;willmount&lt;/li&gt;
&lt;li&gt;didmount&lt;/li&gt;
&lt;li&gt;didupdate&lt;/li&gt;
&lt;li&gt;willmount는 리액트에서 권장하지 않음.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;Mount
컴포넌트가 DOM에 삽입되면 발생한다.
렌더 순서
counstructor &gt; componentWillMount &gt; render &gt; componentDidMount&lt;/p&gt;
&lt;p&gt;componentWillMount()&lt;br&gt;
루트 컴포넌트에서 APP과 관련된 외부 API를 설정할 때 사용한다.&lt;br&gt;
최근에는 리액트에서 사용하지 말라고 권장.&lt;br&gt;
componentDidMount()&lt;br&gt;
자신을 제외한 컴포넌트를 수행한다던지 수정, 초기화, 추가를 할 수 있다.&lt;br&gt;
기본적으로 DOM에 대한 접근이 필요한 모든 설정을 수행하고 필요한 데이터를 가져온다.
DOM 노드가 있어야 하는 초기화 작업은 이 메서드에서 이뤄지면 된다.&lt;br&gt;
외부에서 데이터를 불러와야 한다면 네트워크 요청을 보내기 적절한 위치다.&lt;br&gt;
이 메서드를 사용했다면 반드시 componentWillUnmount()에서 해제 작업을 반드시 해야한다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Update
구성 요소가 업데이트 되거나 상태가 변경 될 때마다 다시 렌더링된다.&lt;br&gt;
렌더 순서&lt;br&gt;
정적 getDerivedStateFromProps &gt; shouldComponentUpdate &gt; 렌더링 &gt;
getSnapshotBeforeUpdate &gt; componentDidUpdate &gt; UNSAFE&lt;em&gt;componentWillUpdate &gt; UNSAFE&lt;/em&gt;componentWillReceiveProps&lt;/p&gt;
&lt;p&gt;shouldComponentUpdate()가 false를 리턴하면 render가 호출되지 않는다.&lt;/p&gt;
&lt;p&gt;shouldComponentUpdate()
리액트의 기본 동작은 모든 상태 변경 후 다시 렌더링하는 것.&lt;br&gt;
컴포넌트가 불안정한 상태, 이 메서드가 호출되었다는 것은 현재 컴포넌트의 상태와 view에 그려진 내용, 상태가 다르다는 것을 의미한다.&lt;br&gt;
shouldComponentUpdate()를 false로 설정하면 렌더를 막을 수 있다.(항상 불린을 반환)&lt;br&gt;
첫번째 인자로 nextProps, 두번째 인자로 nextState 사용(비교한다.)&lt;br&gt;
해당 컴포넌트의렌더를 제어할 때 사용한다.&lt;br&gt;
setState를 사용하면 안된다.&lt;/p&gt;
&lt;p&gt;성능을 최적화하기 위한 방법.
이 방법을 사용하려면 props와 state를 얕게 비교하는 PureComponent를 사용하는 것이 좋다.&lt;/p&gt;
&lt;p&gt;componentDidUpdate()
상태 변경이 발생한 후 네트워크 요청을 하는데 유용하다.
setState를 호출할 경우 무한 루프에 빠진다.&lt;/p&gt;
&lt;p&gt;props change
componentWillReceiveProps &gt; shouldComponentUpdate &gt; componentWillUpdate &gt;
render &gt; componentDidUpdate&lt;/p&gt;
&lt;p&gt;state change
shouldComponentUpdate &gt; componentWillUpdate &gt; render &gt; componentDidUpdate&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;UnMount&lt;br&gt;
컴포넌트가 DOM에서 제거 될 때 호출&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Constructor&lt;br&gt;
생성자는 마운트되기 전에 호출된다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;정적 getDerivedStateFromProps&lt;br&gt;
상태가 시간이 지남에 따라 props의 변화에 의존하는 드문 경우에 사용&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Render&lt;br&gt;
클래스 컴포넌트에서 유일한 필수 메서드
호출 될때 this.props , this.state를 검사한다.
렌더링 할 때마다 상태를 변경하여 많은 버그를 일으킬 수 있으므로 구성 요소 상태를 수정해서는 안된다.&lt;br&gt;
브라우저와 직접 상호 작용하면 안된다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;랜더 순서&lt;br&gt;
부모 컴포넌트의 랜더함수 리턴부터~&lt;/p&gt;
&lt;p&gt;리액트는 UI 라이브러리&lt;br&gt;
라우팅(페이지 전환)은 개발자가 직접 관리해야 한다.&lt;br&gt;
전역(창 끄기 전까지, 페이지 전환해도 어디서든 쓸수 있는)으로 쓸 데이터도 개발자가 관리한다. (리덕스)&lt;br&gt;
라우팅을 도와주는 라우팅 라이브러리.&lt;br&gt;
2차 프로젝트는 next.js(create react, 서버사이드 렌더링 할 수 있게 해줌.)써봐도 됨&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;노드 최신 버전 설치&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;curl -sL https://deb.nodesource.com/setup_10.x | sudo bash -&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;.x 왼쪽 옆에 숫자가 버전임(노드에서 공식 확인해야됨)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;sudo apt install nodejs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;p&gt;클론 후 무조건 npm install (start 하기 전에)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;package.json
 &amp;quot;scripts&amp;quot;: {
    &amp;quot;start&amp;quot;: &amp;quot;react-scripts start&amp;quot;,
    &amp;quot;build&amp;quot;: &amp;quot;react-scripts build&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;react-scripts test&amp;quot;,
    &amp;quot;eject&amp;quot;: &amp;quot;react-scripts eject&amp;quot;
  }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;명령어&lt;br&gt;
start 로컬에서 실시간으로 확인할때&lt;br&gt;
build 작성했던 파일들을 합쳐 결과물을 만들때&lt;br&gt;
test&lt;br&gt;
eject create react가 해제됨(웹팩 사용 잘 할때)&lt;br&gt;
리액트는 각 파일이 독립적이다.(독립적 스코프)&lt;/p&gt;
&lt;p&gt;./ &amp;#x3C;&amp;#x3C;현재 폴더 위치를 뜻한다.
css파일은 결국 다 합쳐지기 때문에 절대 중복되면 안됨.&lt;/p&gt;
&lt;p&gt;라이프 사이클 메서드가 필요하고 자체 스테이트 관리가 필요할 컴포넌트 경우 클래스로 컴포넌트 생성&lt;br&gt;
라이프 사이클 메서드가 필요없고 부모 컴포넌트에게 프롭스를 받기만하는 경우 함수형으로 컴포넌트 생성&lt;br&gt;
프롭스로 부모쪽에서 넘겨주는 경우 자식 컴포넌트가 받기만하면 함수형 컴포넌트(자체 스테이트가 필요없을때)&lt;br&gt;
컴포넌트에서 상태를 유지할 필요가 없는 경우 constructor(생성자)가 필요 없다.&lt;/p&gt;
&lt;p&gt;리액트 라우터 설치&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;yarn add react-router-dom / npm install react-router-dom --save&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;라이프 사이클에 대해 큰 그림 그리고 전체적으로 훑어 봄.&lt;br&gt;
필요에 의해 디테일하게 공부할 예정!!&lt;/p&gt;
&lt;!-- constructor(props) {
console.log()
}
componentDidMount() {

}
componentDidUpdate() {

}
componentWillUnmount() {

}
render() {

} --&gt;</content:encoded></item><item><title><![CDATA[git push 문제 해결]]></title><description><![CDATA[git push 문제 발생에 대해 해결 한 글.]]></description><link>https://khsi12345.github.io//posts/git-push/</link><guid isPermaLink="false">https://khsi12345.github.io//posts/git-push/</guid><pubDate>Mon, 12 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;상황&lt;/p&gt;
&lt;p&gt;내 노트북(로컬)에서 폴더가 존재했고 폴더 안에 html, css, js 파일이 존재했다.&lt;/p&gt;
&lt;p&gt;VSCODE로 작업을 어느정도 하고 github에 올리고 싶어서 github repo를 생성했다.&lt;/p&gt;
&lt;p&gt;github repo와 연결하고 싶은 폴더를 터미널로 열어서 맨 처음 git init을 해줬다.(git 생성. 이제 이 폴더에 git 환경의 조성됨.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;!github repo와 git이 연결된 시점은 아님&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;그리고 어느 블로그들을 보면서 add, commit을 하고&lt;/p&gt;
&lt;p&gt;git과 github를 연결했다. (git remote add origin(굳이 origin이 아니더라도 다른 단어로 해도 됨) repo주소(url))&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;! github repo와 git이 연결된 시점&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;그리고 push를 하는데 에러가 발생한다…&lt;/p&gt;
&lt;p&gt;현재 내 로컬과 github repo(remote)이 일치하지 않는단다… 그러면서 일치시켜주기 위해 git pull을 하라고 힌트를 준다.(github repo(remote)에 있는 것을 내 로컬로 가져오는 것)&lt;/p&gt;
&lt;p&gt;이후 push를 했지만 그래도 에러가 동일하게 발생했다.&lt;/p&gt;
&lt;p&gt;혼자 끙끙 앓다가 해결을 못해 친구에게 sos&lt;/p&gt;
&lt;p&gt;친구가 push 할 때 -f를 사용해 보라고 했다. (git push origin master -f)&lt;/p&gt;
&lt;p&gt;근데 사용해 보라고 하면서 같이 하는 말: &lt;strong&gt;이건 혼자 작업할 때만 써 절대 협업할땐 사용하지 마 github repo(remote)를 내 로컬에 맞추는 거라고..&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;그리고 push하니 에러 발생 없이 잘 되었다.&lt;/p&gt;
&lt;p&gt;하지만 이렇게 해결하는 게 아니고 뭔가 근본적으로 해결하고 싶었다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;위에서 해결된 이유를 보니 github repo(remote)와 내 로컬이 다르지 않기 때문에 성공한 것이었다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그럼 계속 에러가 발생하는 이유는 다르기 때문인 것이다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;그래서 다시 맨 처음으로 돌아갔다.&lt;/p&gt;
&lt;p&gt;repo를 생성했는데 생성하면서 라이센스를 MIT로 설정했었다.(에러 날 때의 상황에서도 repo 생성할 때는 READEME.md 파일 생성할 때도 있었고 안 할 때도 있었다. 하지만 라이센스는 계속 MIT로 설정해주고 있었다.)&lt;/p&gt;
&lt;p&gt;흠 생각해보니 애초에 repo 생성 직후 시점부터 내 로컬과 맞지 않았던 상황이었다.&lt;/p&gt;
&lt;p&gt;그래서 git init으로 로컬에 다시 git을 생성하고 add commit 은 pass 했다.&lt;/p&gt;
&lt;p&gt;대신 바로  git과 github를 연결했다. (git remote add origin(굳이 origin이 아니더라도 다른 단어로 해도 됨) repo주소(url))&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;!github repo와 git이 연결된 시점&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;그리고 이 문제의 근본적인 원인을 해결하기 위해 바로 pull을 해줬다.&lt;/p&gt;
&lt;p&gt;그리고 add, commit, push를 하니 아무 문제도 발생하지 않았다.(성공~~~)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[트위터 클론을 진행하면서]]></title><description><![CDATA[트위터 클론을 진행에 대한 글.]]></description><link>https://khsi12345.github.io//posts/tweet-clone/</link><guid isPermaLink="false">https://khsi12345.github.io//posts/tweet-clone/</guid><pubDate>Mon, 12 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;트위터 클론을 하기 위해 메인 뷰를 html로 먼저 구조화했다.&lt;/p&gt;
&lt;p&gt;기본적으로 html 은 노멀 플로우로서 요소들의 흐름은 위에서 아래이다.&lt;/p&gt;
&lt;p&gt;위에서 기본적으로 html 요소는 노멀 플로우로 흐름이 위에서 아래로 흐른다고 했는데, 위 이미지에서 왼쪽 부분을 보면 트윗 내용들이 위에서 아래로(순차적으로) 내려오는 것을 볼 수 있다.&lt;/p&gt;
&lt;p&gt;반면, 어떤 요소는 왼쪽에 위치해 있고, 어떤 요소는 오른쪽에 위치해 있으며, 텍스트를 입력할 수 있는 요소와 그 밑에 버튼은 왠지 같이 묵여있는거 같아 보이는데 버튼이 오른쪽 끝 즈음에 위치해있다.&lt;/p&gt;
&lt;p&gt;아래 이미지는 html과 css로 직접 따라 만들어본 메인 뷰이다.&lt;/p&gt;
&lt;p&gt;똑같이 만들지는 못했지만 css를 적용해서 요소들을 왼쪽, 오른쪽으로 배치해보았다.&lt;/p&gt;
&lt;p&gt;div 태그는 block 박스 모델로 div 태그로 마크한 요소가 위치한 라인 width를 다 차지한다.&lt;/p&gt;
&lt;p&gt;span 태그는 inline 박스 모델로 span 태그로 마크한 요소가 위치한 곳에서 내용(content)의 크기에 따라 요소의 크기가 정해진다.(내용의 크기 === 요소의 크기)&lt;/p&gt;
&lt;p&gt;input 태그는 type 속성이 있는데 type 속성 중 button 값을 적용했다.&lt;/p&gt;
&lt;p&gt;ul은 리스트 항목(각각의 리스트)을 포함하여 나타낼 때 사용한다.&lt;/p&gt;
&lt;p&gt;자식 요소로 li를 포함할 수 있다.&lt;/p&gt;
&lt;p&gt;li 태그는 개발자 도구에서 확인해보면 display 속성이 block 박스 모델로 보이지는 않는다. 하지만 li 태그로 마크한 요소를 랜더 해보면 block 박스 모델처럼 요소가 위치한 라인 width 전체를 차지한다.&lt;/p&gt;
&lt;p&gt;그리고 li는 리스트 항목(각각의 리스트)을 나타낼 때 사용한다.&lt;/p&gt;
&lt;p&gt;부모 요소로 ol, ul을 포함할 수 있다.&lt;/p&gt;
&lt;p&gt;css는 각 요소들에 class를 지정, class 값을 선택자로 사용해 style을 변경 및 적용했다.&lt;/p&gt;
&lt;p&gt;요소들의 노멀 플로우 흐름에서 벗어나 보내고 싶은 위치로 보낼 때 position, float을 사용했다.&lt;/p&gt;
&lt;p&gt;position은 값으로 relrative, absolute, static, fixed 가 있다.&lt;/p&gt;
&lt;p&gt;relative는 요소가 위치한 기준으로 position relrative를 가지고 있는 요소를 부모로 가지고 있는 요소는 위치의 기준점을 잡을 때 부모 요소를 기준으로 잡게 된다.&lt;/p&gt;
&lt;p&gt;absoulte는 가장 가까이 있는 요소의 position 값을 기준으로, static은 위치 지정 안 하고, fixed는 요소가 위치에 고정&lt;/p&gt;
&lt;p&gt;float은 값으로 left, right를 줄 수 있다.&lt;/p&gt;
&lt;p&gt;float은 이미지를 노멀 플로우에서 벗어나게해서 레이아웃에서 붕 뜨게 보이게 한 뒤 위치를 지정해주고 그 나머지 여백을 텍스트로 감싸주기 위한 목적으로 만들어진 이유다.&lt;/p&gt;
&lt;p&gt;이미지와 텍스트로 조화를 이룬 뷰 페이지로 뉴스? 뉴스 기사? 등등등 에서 유용하게 사용하겠다.&lt;/p&gt;
&lt;p&gt;position: relrative, absolute, fixed   / float: left, right는 top, right, bottom, left 등 위치를 조정할 수 있는 속성을 사용해서 요소의 위치를 디테일하게 다룰 수 있다.&lt;/p&gt;
&lt;p&gt;잘못된 내용 및 오타, 보완해야 할 내용은 댓글로 달아주시면 수정하겠습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[트위터 클론 중 DOM을 사용하며]]></title><description><![CDATA[트위터 클론을 진행에 대한 글.]]></description><link>https://khsi12345.github.io//posts/tweet-clone-DOM/</link><guid isPermaLink="false">https://khsi12345.github.io//posts/tweet-clone-DOM/</guid><pubDate>Mon, 12 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;JS 파일에서 HTML DOM에 접근하는 방법
​
html에 태그, class, id 등 선택자를 설정하고 JS에서 사용한다.(어떻게?? 글을 쭉 읽어봅시다 ~ )&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/dom.png&quot; alt=&quot;DOMIMG&quot;&gt;&lt;/p&gt;
&lt;p&gt;​
document라는 html의 루트에 접근해서 document가 가지고 있는 메서드를 사용했다.&lt;br&gt;
​
querySelector(type: string)를 풀어보면 “선택자를 물어본다”라고 생각할 수 있겠다.
​
그리고 string 타입으로 선택자를 작성해주면 된다.&lt;br&gt;
.으로 시작한것은 class 선택자, #으로 시작하는 것은 id 선택자이다.&lt;br&gt;
​
querySelector() 외에도 getElementById, getElementsByClassName, getElementsByTagName 도 있다.&lt;br&gt;
​
getElementById는 풀어보면 html 요소에 id 속성이 있고 속성의 값이 있을 때 id값으로 해당 요소의 DOM에 접근할 수 있다.&lt;br&gt;
​
document.getElementById(‘id의 값’)&lt;br&gt;
​
&lt;strong&gt;! id는 문서 내에서 유일해야 한다.(유일한 값, 하나밖에 없어야 한다.) 부정의 NOT 아니에요~&lt;/strong&gt;&lt;br&gt;
​
getElementsByClassName는 풀어보면 html 요소에 class 속성이 있고 속성의 값이 있을 때 class값으로 해당 요소의 DOM에 접근할 수 있다.&lt;br&gt;
​
document.getElementsByClassName(‘class의 값’)&lt;br&gt;
​
&lt;strong&gt;! class는 동일한 값이 중복 가능하고, 복수 개의 값을 설정할 수 있다. 부정의 NOT 아니에요~&lt;/strong&gt;&lt;br&gt;
​&lt;/p&gt;
&lt;body&gt;
    &lt;div class=&quot;colorscripter-code&quot; style=&quot;color:#010101;font-family:Consolas, &apos;Liberation Mono&apos;, Menlo, Courier, monospace !important; position:relative !important;overflow:auto&quot;&gt;&lt;table class=&quot;colorscripter-code-table&quot; style=&quot;margin:0;padding:0;border:none;background-color:#fafafa;border-radius:4px;&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tr&gt;&lt;td style=&quot;padding:6px;border-right:2px solid #e5e5e5&quot;&gt;&lt;div style=&quot;margin:0;padding:0;word-break:normal;text-align:right;color:#666;font-family:Consolas, &apos;Liberation Mono&apos;, Menlo, Courier, monospace !important;line-height:130%&quot;&gt;&lt;div style=&quot;line-height:130%&quot;&gt;1&lt;/div&gt;&lt;div style=&quot;line-height:130%&quot;&gt;2&lt;/div&gt;&lt;div style=&quot;line-height:130%&quot;&gt;3&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;td style=&quot;padding:6px 0;text-align:left&quot;&gt;&lt;div style=&quot;margin:0;padding:0;color:#010101;font-family:Consolas, &apos;Liberation Mono&apos;, Menlo, Courier, monospace !important;line-height:130%&quot;&gt;&lt;div style=&quot;padding:0 6px; white-space:pre; line-height:130%&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#010101&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color:#066de2&quot;&gt;div&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#0a9989&quot;&gt;class&lt;/span&gt;=&lt;span style=&quot;color:#df5000&quot;&gt;&quot;duple&quot;&lt;/span&gt;&lt;span style=&quot;color:#0a9989&quot;&gt;&lt;/span&gt;&lt;span style=&quot;color:#010101&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#010101&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color:#010101&quot;&gt;/&lt;/span&gt;&lt;span style=&quot;color:#066de2&quot;&gt;div&lt;/span&gt;&lt;span style=&quot;color:#010101&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;padding:0 6px; white-space:pre; line-height:130%&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#010101&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color:#066de2&quot;&gt;p&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#0a9989&quot;&gt;class&lt;/span&gt;=&lt;span style=&quot;color:#df5000&quot;&gt;&quot;duple&quot;&lt;/span&gt;&lt;span style=&quot;color:#0a9989&quot;&gt;&lt;/span&gt;&lt;span style=&quot;color:#010101&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&quot;color:#010101&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color:#010101&quot;&gt;/&lt;/span&gt;&lt;span style=&quot;color:#066de2&quot;&gt;p&lt;/span&gt;&lt;span style=&quot;color:#010101&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div style=&quot;padding:0 6px; white-space:pre; line-height:130%&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;span style=&quot;color:#010101&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&quot;color:#066de2&quot;&gt;input&lt;/span&gt;&amp;nbsp;&lt;span style=&quot;color:#0a9989&quot;&gt;class&lt;/span&gt;=&lt;span style=&quot;color:#df5000&quot;&gt;&quot;inputName&amp;nbsp;inputEle&quot;&lt;/span&gt;&lt;span style=&quot;color:#0a9989&quot;&gt;&lt;/span&gt;&lt;span style=&quot;color:#010101&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;td style=&quot;vertical-align:bottom;padding:0 2px 4px 0&quot;&gt;&lt;a href=&quot;http://colorscripter.com/info#e&quot; target=&quot;_blank&quot; style=&quot;text-decoration:none;color:white&quot;&gt;&lt;span style=&quot;font-size:9px;word-break:normal;background-color:#e5e5e5;color:white;border-radius:10px;padding:1px&quot;&gt;cs&lt;/span&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;p&gt;querySelector()는 id, class를 구분해서 querySelector()에게 넘겨줘야 하고
​
getElementById(), getElementsByClassName()는 무조건 id, 무조건 class 정해져 있기 때문에 정해진 선택자로
​
getElementById(), getElementsByClassName()에게 넘겨줘야 한다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[트위터 클론 중 event 사용하며]]></title><description><![CDATA[트위터 클론을 진행에 대한 글.]]></description><link>https://khsi12345.github.io//posts/tweet-clone-event/</link><guid isPermaLink="false">https://khsi12345.github.io//posts/tweet-clone-event/</guid><pubDate>Mon, 12 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;로그인 페이지&lt;/p&gt;
&lt;p&gt;이벤트를 걸어주려면 해당 DOM에 접근을 해야 한다.&lt;/p&gt;
&lt;p&gt;document.querySelector()로 접근을 했다.&lt;/p&gt;
&lt;p&gt;그리고 접근한 DOM에 이벤트를 걸어줬다.&lt;/p&gt;
&lt;p&gt;Phon Nuber 또는 Email을 입력하면 빨간색 텍스트가 없어지게 만들고&lt;/p&gt;
&lt;p&gt;reset 하면 다시 빨간 색 텍스트가 보이게 만들자.&lt;/p&gt;
&lt;p&gt;해당 입력창(DOM)에 아무 입력을 하지 않으면&lt;/p&gt;
&lt;p&gt;밑에 text가 기본으로 보인다.&lt;/p&gt;
&lt;p&gt;입력을 하면 밑에 text가 보이지 않게 만들자.&lt;/p&gt;
&lt;p&gt;해당 입력창(DOM)에 입력을 하면 &lt;br&gt;
DOM에 setAttribute()를 사용해서&lt;br&gt;
입력창 밑에 tex가 보이지 않게 css 속성을 추가해줬다.&lt;/p&gt;
&lt;p&gt;입력창을 다시 reset하면 밑 text가 다시 보인다.&lt;/p&gt;
&lt;p&gt;-------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;입력창 2개에 입력을 하면 Log in 버튼 배경색을 변경해서&lt;br&gt;
활성화되는 것처럼 보이게 만들자.&lt;/p&gt;
&lt;p&gt;Log in 버튼 기본 배경색은 회색으로 설정되어 있는 상태고&lt;/p&gt;
&lt;p&gt;입력창 2개에 입력을 하면 DOM에 setAttribute()를 사용해서&lt;/p&gt;
&lt;p&gt;배경색을 변경해줬다.&lt;/p&gt;
&lt;p&gt;입력창 1개를 입력하지 않으면&lt;/p&gt;
&lt;p&gt;Log in 버튼 배경색은 기본으로 회색 그대로이고&lt;/p&gt;
&lt;p&gt;입력창 2개를 다 입력했다가 1개를 reset 시키면&lt;/p&gt;
&lt;p&gt;2개 입력했을 때 버튼 배경색이 바뀌었다가&lt;br&gt;
1개를 reset 시키면 다시 기본 배경색으로 바뀐다.&lt;/p&gt;
&lt;p&gt;이벤트는 2개의 DOM에 걸어줬는데 DOM에 접근한 개수는 총 4개다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;이벤트를 걸어주기 위해서만 DOM에 접근하는 것은 아니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DOM에 접근하는 이유는 해당 DOM을 컨트롤하기 위해서다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;코드 로직은 이벤트가 발생했을 때 실행시킬 코드를 함수를 만들어 작성하고&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;함수를 이벤트 리스너에게 넘겨주었다.(콜백 함수)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;회원가입 페이지&lt;/p&gt;
&lt;p&gt;DOM에 접근을 해서 입력창과 버튼을&lt;/p&gt;
&lt;p&gt;컨트롤하겠다.&lt;/p&gt;
&lt;p&gt;모든 입력창에 입력을 해야 Sign up 버튼이&lt;/p&gt;
&lt;p&gt;색이 변경되면서 활성화되는 것처럼 보이는데&lt;/p&gt;
&lt;p&gt;로직을 작성하려고 보니 이벤트 리스너와&lt;/p&gt;
&lt;p&gt;이벤트가 발생했을 때 실행시킬 코드가&lt;/p&gt;
&lt;p&gt;상당히 중복될 가능성이 있어 보인다.&lt;/p&gt;
&lt;p&gt;모든 입력창 DOM에 class를 동일하게 주고 &lt;br&gt;
(&lt;strong&gt;class는 유니크하지 않아요!!&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;getElementsByClassName으로 접근했다.&lt;/p&gt;
&lt;p&gt;하지만 이 녀석은 &lt;strong&gt;DOM 객체를 반환하지 않고&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DOM 객체들을 묶어 유사 배열 형태로 반환&lt;/strong&gt;한다.&lt;/p&gt;
&lt;p&gt;DOM 객체로 받으려면&lt;/p&gt;
&lt;p&gt;getElementsByClassName().[index]로 콕 집어줘야 한다.&lt;/p&gt;
&lt;p&gt;(index라고 그대로 쓰면 안 됩니다. 배열 또는 배열 형태가 가지고 있는 index 값을 줘야 해요~)&lt;/p&gt;
&lt;p&gt;DOM 객체가 필요하지만 getElementsByClassName().[index]로 쓰면&lt;/p&gt;
&lt;p&gt;결국 querySelector()로 각각의 해당 요소에 접근하는 방법과 같아진다.&lt;/p&gt;
&lt;p&gt;나에게 필요한 건 getElementsByClassName()으로&lt;/p&gt;
&lt;p&gt;유사 배열 형태로 이뤄진 DOM 객체들이다.&lt;/p&gt;
&lt;p&gt;그리고 반복문을 돌려서 효율적으로 작성하려 한다.&lt;/p&gt;
&lt;p&gt;어라????? 반복문을 돌리려 forEach를 사용했는데 에러가 발생한다!!&lt;/p&gt;
&lt;p&gt;무슨 문제가 있나 보다… MDN 및 구글링~&lt;/p&gt;
&lt;p&gt;오호라~ 좀 번외이긴 하지만 JS에서는 배열도 Object(객체)다. (typeof으로 검사해보면 object로 떠요~)&lt;/p&gt;
&lt;p&gt;그래서 데이터가 배열인지 아닌지 확인하려면 Array.isArray() 메서드를 사용해서 확인해야 한다.&lt;/p&gt;
&lt;p&gt;확인해보니 false라 뜬다. (배열이 아니구나… 근데 배열이 아닌데 배열처럼 묶여있네?? 이런 걸 유사 배열이라 하네)&lt;/p&gt;
&lt;p&gt;유사 배열은 배열이 아니고, 배열처럼 index는 가진다.(배열이 아니라서 배열의 메서드들을 사용할 수 없다.)&lt;/p&gt;
&lt;p&gt;그래서 유사 배열을 배열로 만들려고 한다.&lt;/p&gt;
&lt;p&gt;Array.prototype.slice.call()을 사용해서 말이다.&lt;/p&gt;
&lt;p&gt;Array(배열)가 가지고 있는 slice 메서드를 call이라는 녀석으로 호출했다. (slice는 받은 데이터를 복사해서 원본 데이터와 전혀 다른 새로운 데이터를 반환한다.)&lt;/p&gt;
&lt;p&gt;그리고 () 안에 유사배열을 넘겨줬다.&lt;/p&gt;
&lt;p&gt;이제 배열로 만들어줬으니 반복문을 돌려도 에러가 발생하지 않는다.&lt;/p&gt;
&lt;p&gt;반복문으로 각각의 DOM 객체를 불러올 수 있게 됐다.&lt;/p&gt;
&lt;p&gt;각각의 DOM 객체를 불러와 이벤트 리스너를 걸어주고 이벤트가 발생했을 때 실행시킬 코드를 작성했다.&lt;/p&gt;
&lt;p&gt;이렇게 코드를 작성하니 &lt;strong&gt;중복이 없다.&lt;/strong&gt;(개발자는 중복이 귀찮고 싫잖아요? 인정하셔야 돼요!! )&lt;/p&gt;
&lt;p&gt;로그인 페이지에서는 컨트롤할 DOM이 적으니 1~2개 중복은 괜찮지만 확장되면서 중복이 되면 유지 보수하기 힘들 것 같다.(매우)&lt;/p&gt;
&lt;p&gt;그래서 회원가입 페이지에서는 최대한 중복을 제외하는 로직으로 코드를 작성했다.&lt;/p&gt;
&lt;p&gt;피드백 언제나 환영합니다 ~&lt;/p&gt;</content:encoded></item><item><title><![CDATA[트위터 클론 중 textarea 최대 글자 수 제한 이벤트]]></title><description><![CDATA[트위터 클론을 진행에 대한 글.]]></description><link>https://khsi12345.github.io//posts/tweet-clone-textarea-event/</link><guid isPermaLink="false">https://khsi12345.github.io//posts/tweet-clone-textarea-event/</guid><pubDate>Mon, 12 Aug 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;작성을 텍스트 위주로 해서 전체 코드를 &lt;a href=&quot;https://github.com/khsi12345/miniter&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener noreferrer&quot;&gt;https://github.com/khsi12345/miniter&lt;/a&gt; 에서 확인해주세요~&lt;/p&gt;
&lt;p&gt;전체적인 코드와 글을 같이 보면 좋습니다.&lt;/p&gt;
&lt;p&gt;1. textarea 요소 dom 객체에 접근하기 위해서 js 파일에서 document.querySelector(’. textBox’)를&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let  textArea  \=  document.querySelector(&amp;#39;.textBox&amp;#39;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.textarea dom에 접근할 수 있게 됐으니 이벤트를 걸어줄 수 있게 됐다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;textArea.addEventListener(&amp;#39;event option&amp;#39;, function(e) {
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이벤트가 발생할 때까지 감시하고 있어줄 addEventListener!&lt;/p&gt;
&lt;p&gt;이벤트가 발생할때 까지 감시하고 있기는 하는데~~ 어떤 이벤트인지 알아야 하니까 1번째 인자로 이벤트 옵션을 설정해준다.&lt;/p&gt;
&lt;p&gt;(이벤트가 발생될 때까지 감시하고 있다가 설정해준 이벤트가 발생하면 감지하고 실행한다.)&lt;/p&gt;
&lt;p&gt;이벤트가 발생했을 때 2번째 인자로 주어지는 로직을 실행한다.(비동기)&lt;/p&gt;
&lt;p&gt;3.textarea는 입력창이니까 사용자가 키보드를 사용할 거야, 그럼 키보드 관련 이벤트를 걸어줘야겠지?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;textArea.addEventListener(&amp;#39;keyup&amp;#39;,function(e) {

})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;키보드 옵션이 keyup, keydown, keypress 있는데 keyup을 설정해줬다.&lt;/p&gt;
&lt;p&gt;keyup은 키보드를 눌렀다 땠을 때의 이벤트&lt;/p&gt;
&lt;p&gt;4. 이제 이벤트가 발생했고, 2번째 인자로 실행될 로직을 만들어보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;textArea.addEventListener(&amp;#39;keyup&amp;#39;, function(e) {

// console.log(e)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;함수의 인자로 해당 dom 객체에서 발생한 이벤트 객체를 받아 올 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;if(e.target.value.length &amp;lt;= maxContentsOfTextArea) curContents.innerHTML = e.target.value.length;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 로직은 입력한 글자의 수를 뷰에 표현&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;if(e.target.value.length &amp;gt;= maxContentsOfTextArea) {

const contents = e.target.value;

//이벤트 옵션이 keyup 일 때

// console.log(contents.slice(0, maxContentsOfTextArea))

// e.target.value = contents.slice(0, maxContentsOfTextArea);

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 로직은 입력한 글자의 수가 최대 글자의 수와 같아져도 textarea에 계속 입력할 수 있다.(최대 글자 수를 오버해서 입력이 되는 문제 발생…)&lt;/p&gt;
&lt;p&gt;그래서 입력한 글자의 수가 최대 글자의 수와 같아지거나, 길어질 때 최대 글자 수까지만 view에 표현하기 위한 로직이다.&lt;/p&gt;
&lt;p&gt;위 초록색 로직으로 작성한 이유는 keyup 이벤트 때문이다.&lt;/p&gt;
&lt;p&gt;(이미 키를 눌렀다 떼서 이벤트가 발생한 시점으로 event.preventDefault()가 먹히지 않는다.)&lt;/p&gt;
&lt;p&gt;})&lt;/p&gt;
&lt;p&gt;다르게도 로직을 작성해봤다. (아래 로직)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;textArea.addEventListener(&amp;#39;keydown&amp;#39;, function(e) {

// console.log(e)

if(e.target.value.length &amp;lt;= maxContentsOfTextArea) curContents.innerHTML = e.target.value.length;

if(e.target.value.length &amp;gt;= maxContentsOfTextArea) {

//이벤트 옵션이 keydown 일 때

if(e.keyCode!== 8) {

event.preventDefault();

}

}

})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;keyup 이벤트 옵션을 keydown으로 변경해주었다.&lt;/p&gt;
&lt;p&gt;keydown은 키를 누를 때 이벤트가 발생해서 event.preventDefault()가 먹힌다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;하지만 문자를 입력하면 최대 글자 수를 오버해서 계속 입력이 된다…(해결하려고 삽질을 했지만 결국 실패)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;또 다른 문제 입력한 문자의 수와 뷰에 표시되는 숫자가 다르다…(이것도 실패)&lt;/p&gt;
&lt;p&gt;백스페이스 키가 먹히지 않는다.&lt;/p&gt;
&lt;p&gt;그래서 if 조건문으로 백스페이스는 예외 적용을 해주었다.(잘 먹힌다..)&lt;/p&gt;</content:encoded></item></channel></rss>